
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="存放和分享笔者的一些笔记和随笔">
      
      
        <meta name="author" content="Yunzinan">
      
      
      <link rel="icon" href="../../img/favicon.png">
      <meta name="generator" content="mkdocs-1.3.1, mkdocs-material-8.4.2">
    
    
      
        <title>力扣刷题笔记 - Yunzinan的知识库</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.69437709.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#2094f3">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Jetbrains+Mono:300,300i,400,400i,700,700i%7CJetbrains+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Jetbrains Mono";--md-code-font:"Jetbrains Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="blue" data-md-color-accent="lime">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#leetcode" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="Yunzinan的知识库" class="md-header__button md-logo" aria-label="Yunzinan的知识库" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Yunzinan的知识库
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              力扣刷题笔记
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/yunzinan/Note_Base" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    Note_Base
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  <li class="md-tabs__item">
    <a href="../.." class="md-tabs__link">
      主页
    </a>
  </li>

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../Math/Caculus/Calculus-II-notes-chapt1/" class="md-tabs__link">
        数学
      </a>
    </li>
  

  

      
        
  
  
    
  


  
  
  
    <li class="md-tabs__item">
      <a href="./" class="md-tabs__link md-tabs__link--active">
        计算机科学
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../Chemistry/%E5%A4%A7%E5%AD%A6%E5%8C%96%E5%AD%A6%E7%AC%94%E8%AE%B0/" class="md-tabs__link">
        化学
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../SkillMap/Jupyter-notebook%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="md-tabs__link">
        技能树
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../LectureNotes/%E9%A9%AC%E5%8E%9F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/" class="md-tabs__link">
        课堂笔记
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../InformalEssay/%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98-%E5%8F%AF%E7%A7%AF%E4%B8%80%E5%AE%9A%E6%9C%89%E5%8E%9F%E5%87%BD%E6%95%B0%E5%90%97/" class="md-tabs__link">
        随笔
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../OJ/%E8%AD%A6%E9%92%9F%E9%95%BF%E9%B8%A3-%E9%A2%98%E5%8D%95/" class="md-tabs__link">
        OJ
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../CheatSheet/mkdocs%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95/" class="md-tabs__link">
        CheatSheet
      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Yunzinan的知识库" class="md-nav__button md-logo" aria-label="Yunzinan的知识库" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Yunzinan的知识库
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/yunzinan/Note_Base" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    Note_Base
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        主页
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          数学
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="数学" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          数学
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_1" type="checkbox" id="__nav_2_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_1">
          微积分II
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="微积分II" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_1">
          <span class="md-nav__icon md-icon"></span>
          微积分II
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/Caculus/Calculus-II-notes-chapt1/" class="md-nav__link">
        chap 1
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/Caculus/Calculus-II-notes-chapt2/" class="md-nav__link">
        chap 2
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/Caculus/Calculus-II-notes-chapt3/" class="md-nav__link">
        chap 3
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/Caculus/Calculus-II-notes-chapt4/" class="md-nav__link">
        chap 4
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/Caculus/Calculus-II-notes-chapt5/" class="md-nav__link">
        chap 5
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/Caculus/Calculus-II-notes-chapt6/" class="md-nav__link">
        chap 6
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/Caculus/Calculus-II-midterm-review/" class="md-nav__link">
        midterm review
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/Caculus/Calculus-II-final-review/" class="md-nav__link">
        final review
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_2" type="checkbox" id="__nav_2_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_2">
          离散数学
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="离散数学" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_2">
          <span class="md-nav__icon md-icon"></span>
          离散数学
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/DiscreteMath/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0-%E4%BB%A3%E6%95%B0%E7%BB%93%E6%9E%84-%E4%BB%A3%E6%95%B0%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        代数系统
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/DiscreteMath/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0-%E4%BB%A3%E6%95%B0%E7%BB%93%E6%9E%84-%E7%BE%A4%E4%B8%8E%E7%8E%AF/" class="md-nav__link">
        群与环
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/DiscreteMath/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0-%E4%BB%A3%E6%95%B0%E7%B3%BB%E7%BB%9F-%E6%A0%BC%E4%B8%8E%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0/" class="md-nav__link">
        格与布尔代数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/DiscreteMath/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA-%E6%94%AF%E9%85%8D%E4%B8%8E%E7%9D%80%E8%89%B2/" class="md-nav__link">
        支配与着色
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/DiscreteMath/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA%E9%83%A8%E5%88%86-%E6%AC%A7%E6%8B%89%E5%9B%BE%E4%B8%8E%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE/" class="md-nav__link">
        欧拉图与哈密顿图
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/DiscreteMath/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA%E9%83%A8%E5%88%86-%E6%A0%91/" class="md-nav__link">
        树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/DiscreteMath/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA%E9%83%A8%E5%88%86-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="md-nav__link">
        图的基本概念
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/DiscreteMath/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        课堂笔记
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Math/LinearAlgebra/Linear-algebra-notes/" class="md-nav__link">
        线性代数
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          计算机科学
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="计算机科学" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          计算机科学
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          力扣刷题笔记
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        力扣刷题笔记
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    知识学习
  </a>
  
    <nav class="md-nav" aria-label="知识学习">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cstl" class="md-nav__link">
    C++STL容器学习
  </a>
  
    <nav class="md-nav" aria-label="C++STL容器学习">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#vector" class="md-nav__link">
    vector
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string" class="md-nav__link">
    string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stack" class="md-nav__link">
    stack
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#queue" class="md-nav__link">
    queue
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#priority_queue" class="md-nav__link">
    priority_queue
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set-unordered_set" class="md-nav__link">
    set (unordered_set)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#map" class="md-nav__link">
    map
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pair" class="md-nav__link">
    pair
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#list" class="md-nav__link">
    list
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#algorithm" class="md-nav__link">
    algorithm头文件下的常用函数
  </a>
  
    <nav class="md-nav" aria-label="algorithm头文件下的常用函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sort" class="md-nav__link">
    sort()函数的用法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stable_sort" class="md-nav__link">
    stable_sort用法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lower_bound-upper_bound" class="md-nav__link">
    lower_bound &amp; upper_bound()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    数据结构
  </a>
  
    <nav class="md-nav" aria-label="数据结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    树
  </a>
  
    <nav class="md-nav" aria-label="树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    树的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst" class="md-nav__link">
    BST 二叉搜索树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avl" class="md-nav__link">
    AVL树 平衡二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    并查集
  </a>
  
    <nav class="md-nav" aria-label="并查集">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    路径压缩
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    字典树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    哈夫曼树（最优二叉树）
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    栈
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    队列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    树状数组
  </a>
  
    <nav class="md-nav" aria-label="树状数组">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lowbit" class="md-nav__link">
    预备知识：lowbit()运算
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    哈希（散列）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    优先队列（堆）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    图
  </a>
  
    <nav class="md-nav" aria-label="图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    图的存储：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    - 链式前向星
  </a>
  
    <nav class="md-nav" aria-label="- 链式前向星">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dfs" class="md-nav__link">
    图的遍历：深搜（DFS）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bfs" class="md-nav__link">
    图的遍历：广搜（BFS）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aa" class="md-nav__link">
    图的遍历：A^*A^*算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#minimal-spanning-tree-prim" class="md-nav__link">
    最小生成树 (Minimal Spanning Tree) ：prim算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mstkruskal" class="md-nav__link">
    最小生成树（MST）：Kruskal算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dijkstra" class="md-nav__link">
    单源最短路径：Dijkstra算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    拓扑排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tarjan" class="md-nav__link">
    强连通分量求法：Tarjan算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    图中是否存在环的判断
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    算法
  </a>
  
    <nav class="md-nav" aria-label="算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    排序和搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    二分查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dp" class="md-nav__link">
    dp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    蓄水池抽样
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    刷题记录（补充知识+做题经验）
  </a>
  
    <nav class="md-nav" aria-label="刷题记录（补充知识+做题经验）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#check" class="md-nav__link">
    二分+check
  </a>
  
    <nav class="md-nav" aria-label="二分+check">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc5219" class="md-nav__link">
    LC5219 每个小孩最多能分到多少糖果
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    栈
  </a>
  
    <nav class="md-nav" aria-label="栈">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc150" class="md-nav__link">
    LC150 逆波兰表达式求值
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    并查集
  </a>
  
    <nav class="md-nav" aria-label="并查集">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc547" class="md-nav__link">
    LC547 省份数量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lc1319" class="md-nav__link">
    LC1319 连通网络的操作次数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    二叉树
  </a>
  
    <nav class="md-nav" aria-label="二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc889" class="md-nav__link">
    LC889 根据前序和后序遍历构造二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    字典树
  </a>
  
    <nav class="md-nav" aria-label="字典树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc440-k" class="md-nav__link">
    LC440 字典序的第K小数字
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    图
  </a>
  
    <nav class="md-nav" aria-label="图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    出度、入度
  </a>
  
    <nav class="md-nav" aria-label="出度、入度">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc997" class="md-nav__link">
    LC997 找到小镇的法官
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bfs_1" class="md-nav__link">
    BFS
  </a>
  
    <nav class="md-nav" aria-label="BFS">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc417" class="md-nav__link">
    LC417 太平洋大西洋水流问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lc934" class="md-nav__link">
    LC934 最短的桥
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dijkstra-single-source-shortest-pathsssp-algorithm" class="md-nav__link">
    Dijkstra- Single Source Shortest Path(SSSP) algorithm
  </a>
  
    <nav class="md-nav" aria-label="Dijkstra- Single Source Shortest Path(SSSP) algorithm">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc743" class="md-nav__link">
    LC743 网络延迟时间
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    哈希表
  </a>
  
    <nav class="md-nav" aria-label="哈希表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc599" class="md-nav__link">
    LC599 两个列表的最小索引总和
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dp_1" class="md-nav__link">
    dp
  </a>
  
    <nav class="md-nav" aria-label="dp">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc1575" class="md-nav__link">
    LC1575 统计所有可行路径
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    凸包算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    技巧
  </a>
  
    <nav class="md-nav" aria-label="技巧">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    读题与分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    打表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#two-pointers" class="md-nav__link">
    two pointers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    滑动窗口（双指针）
  </a>
  
    <nav class="md-nav" aria-label="滑动窗口（双指针）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc-3" class="md-nav__link">
    LC 3 无重复字符的最长字串
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    前缀和&amp;差分
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gridtrick" class="md-nav__link">
    二维grid上下左右移动的小trick
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    浮点数出现精度丢失的问题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        高级程序设计
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="md-nav__link">
        数据结构
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        数据结构复习笔记
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E7%94%B5%E8%AE%A1%E7%BB%84/" class="md-nav__link">
        数字逻辑与计算机组成
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E7%94%B5%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/" class="md-nav__link">
        数电计组复习
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          化学
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="化学" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          化学
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Chemistry/%E5%A4%A7%E5%AD%A6%E5%8C%96%E5%AD%A6%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        大学化学
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Chemistry/%E6%9C%89%E6%9C%BA%E5%8C%96%E5%AD%A6%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        有机化学
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Chemistry/%E4%BB%AA%E5%99%A8%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        仪器分析
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Chemistry/%E4%BB%AA%E5%99%A8%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A/" class="md-nav__link">
        仪器分析作业
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Chemistry/%E6%9C%89%E6%9C%BA%E5%8C%96%E5%AD%A6%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        有机化学学习指南笔记
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          技能树
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="技能树" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          技能树
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SkillMap/Jupyter-notebook%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="md-nav__link">
        Jupyter Notebook
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SkillMap/WebCrawlingNotes/" class="md-nav__link">
        爬虫入门
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SkillMap/gdb_note/" class="md-nav__link">
        gdb入门
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          课堂笔记
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="课堂笔记" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          课堂笔记
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LectureNotes/%E9%A9%AC%E5%8E%9F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/" class="md-nav__link">
        马原
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LectureNotes/%E6%99%AE%E9%80%9A%E7%89%A9%E7%90%86I%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        普通物理I
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LectureNotes/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        中国近代史纲要
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../LectureNotes/%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="md-nav__link">
        高级程序设计
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7" type="checkbox" id="__nav_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7">
          随笔
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="随笔" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          随笔
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../InformalEssay/%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98-%E5%8F%AF%E7%A7%AF%E4%B8%80%E5%AE%9A%E6%9C%89%E5%8E%9F%E5%87%BD%E6%95%B0%E5%90%97/" class="md-nav__link">
        可积一定有原函数吗?
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../InformalEssay/22SummerReview/" class="md-nav__link">
        22SummerReview
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../InformalEssay/%E5%AF%B9%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%9D%E8%80%83/" class="md-nav__link">
        对个人笔记系统的思考
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../InformalEssay/%E4%B8%80%E4%BA%9BLaTeX%E8%AF%AD%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98/" class="md-nav__link">
        都是语法惹的祸
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../InformalEssay/%E7%88%AC%E8%99%AB%E8%BF%9B%E9%98%B6-ip%E4%BB%A3%E7%90%86/" class="md-nav__link">
        ip代理爬虫
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../InformalEssay/%E5%8F%AB%E9%AD%82%E4%B9%A6%E8%AF%84/" class="md-nav__link">
        <叫魂-1768年妖术大恐慌>书评
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../InformalEssay/22FallReview/" class="md-nav__link">
        22FallReview
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../InformalEssay/%E4%BB%8EChatGPT%E7%9C%8BAI%3A%E6%9C%AA%E6%9D%A5%E4%BB%A5%E6%9D%A5/" class="md-nav__link">
        从ChatGPT看AI-未来以来
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../InformalEssay/wsl/" class="md-nav__link">
        WSL
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../InformalEssay/marp/" class="md-nav__link">
        如何优雅地写slides?
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_8" type="checkbox" id="__nav_8" >
      
      
      
      
        <label class="md-nav__link" for="__nav_8">
          OJ
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="OJ" data-md-level="1">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          OJ
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../OJ/%E8%AD%A6%E9%92%9F%E9%95%BF%E9%B8%A3-%E9%A2%98%E5%8D%95/" class="md-nav__link">
        警钟长鸣
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_9" type="checkbox" id="__nav_9" >
      
      
      
      
        <label class="md-nav__link" for="__nav_9">
          CheatSheet
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="CheatSheet" data-md-level="1">
        <label class="md-nav__title" for="__nav_9">
          <span class="md-nav__icon md-icon"></span>
          CheatSheet
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../CheatSheet/mkdocs%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95/" class="md-nav__link">
        mkdocs扩展语法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../CheatSheet/regex-cookbook/" class="md-nav__link">
        regex教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../CheatSheet/markdown-emoji/" class="md-nav__link">
        emoji-cheat-sheet
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../CheatSheet/vim-CheatSheet/" class="md-nav__link">
        vim-cheat-sheet
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    知识学习
  </a>
  
    <nav class="md-nav" aria-label="知识学习">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cstl" class="md-nav__link">
    C++STL容器学习
  </a>
  
    <nav class="md-nav" aria-label="C++STL容器学习">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#vector" class="md-nav__link">
    vector
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string" class="md-nav__link">
    string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stack" class="md-nav__link">
    stack
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#queue" class="md-nav__link">
    queue
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#priority_queue" class="md-nav__link">
    priority_queue
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set-unordered_set" class="md-nav__link">
    set (unordered_set)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#map" class="md-nav__link">
    map
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pair" class="md-nav__link">
    pair
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#list" class="md-nav__link">
    list
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#algorithm" class="md-nav__link">
    algorithm头文件下的常用函数
  </a>
  
    <nav class="md-nav" aria-label="algorithm头文件下的常用函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sort" class="md-nav__link">
    sort()函数的用法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stable_sort" class="md-nav__link">
    stable_sort用法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lower_bound-upper_bound" class="md-nav__link">
    lower_bound &amp; upper_bound()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    数据结构
  </a>
  
    <nav class="md-nav" aria-label="数据结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    树
  </a>
  
    <nav class="md-nav" aria-label="树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    树的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bst" class="md-nav__link">
    BST 二叉搜索树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avl" class="md-nav__link">
    AVL树 平衡二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    并查集
  </a>
  
    <nav class="md-nav" aria-label="并查集">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    路径压缩
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    字典树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    哈夫曼树（最优二叉树）
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    栈
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    队列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    树状数组
  </a>
  
    <nav class="md-nav" aria-label="树状数组">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lowbit" class="md-nav__link">
    预备知识：lowbit()运算
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    哈希（散列）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    优先队列（堆）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    图
  </a>
  
    <nav class="md-nav" aria-label="图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    图的存储：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    - 链式前向星
  </a>
  
    <nav class="md-nav" aria-label="- 链式前向星">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dfs" class="md-nav__link">
    图的遍历：深搜（DFS）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bfs" class="md-nav__link">
    图的遍历：广搜（BFS）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aa" class="md-nav__link">
    图的遍历：A^*A^*算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#minimal-spanning-tree-prim" class="md-nav__link">
    最小生成树 (Minimal Spanning Tree) ：prim算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mstkruskal" class="md-nav__link">
    最小生成树（MST）：Kruskal算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dijkstra" class="md-nav__link">
    单源最短路径：Dijkstra算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    拓扑排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tarjan" class="md-nav__link">
    强连通分量求法：Tarjan算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    图中是否存在环的判断
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    算法
  </a>
  
    <nav class="md-nav" aria-label="算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    排序和搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    二分查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dp" class="md-nav__link">
    dp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    蓄水池抽样
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    刷题记录（补充知识+做题经验）
  </a>
  
    <nav class="md-nav" aria-label="刷题记录（补充知识+做题经验）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#check" class="md-nav__link">
    二分+check
  </a>
  
    <nav class="md-nav" aria-label="二分+check">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc5219" class="md-nav__link">
    LC5219 每个小孩最多能分到多少糖果
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    栈
  </a>
  
    <nav class="md-nav" aria-label="栈">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc150" class="md-nav__link">
    LC150 逆波兰表达式求值
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    并查集
  </a>
  
    <nav class="md-nav" aria-label="并查集">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc547" class="md-nav__link">
    LC547 省份数量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lc1319" class="md-nav__link">
    LC1319 连通网络的操作次数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    二叉树
  </a>
  
    <nav class="md-nav" aria-label="二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc889" class="md-nav__link">
    LC889 根据前序和后序遍历构造二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    字典树
  </a>
  
    <nav class="md-nav" aria-label="字典树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc440-k" class="md-nav__link">
    LC440 字典序的第K小数字
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    图
  </a>
  
    <nav class="md-nav" aria-label="图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    出度、入度
  </a>
  
    <nav class="md-nav" aria-label="出度、入度">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc997" class="md-nav__link">
    LC997 找到小镇的法官
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bfs_1" class="md-nav__link">
    BFS
  </a>
  
    <nav class="md-nav" aria-label="BFS">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc417" class="md-nav__link">
    LC417 太平洋大西洋水流问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lc934" class="md-nav__link">
    LC934 最短的桥
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dijkstra-single-source-shortest-pathsssp-algorithm" class="md-nav__link">
    Dijkstra- Single Source Shortest Path(SSSP) algorithm
  </a>
  
    <nav class="md-nav" aria-label="Dijkstra- Single Source Shortest Path(SSSP) algorithm">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc743" class="md-nav__link">
    LC743 网络延迟时间
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    哈希表
  </a>
  
    <nav class="md-nav" aria-label="哈希表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc599" class="md-nav__link">
    LC599 两个列表的最小索引总和
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dp_1" class="md-nav__link">
    dp
  </a>
  
    <nav class="md-nav" aria-label="dp">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc1575" class="md-nav__link">
    LC1575 统计所有可行路径
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    凸包算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    技巧
  </a>
  
    <nav class="md-nav" aria-label="技巧">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    读题与分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    打表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#two-pointers" class="md-nav__link">
    two pointers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    滑动窗口（双指针）
  </a>
  
    <nav class="md-nav" aria-label="滑动窗口（双指针）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lc-3" class="md-nav__link">
    LC 3 无重复字符的最长字串
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    前缀和&amp;差分
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gridtrick" class="md-nav__link">
    二维grid上下左右移动的小trick
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    浮点数出现精度丢失的问题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


<h1 id="leetcode">LeetCode 刷题笔记<a class="headerlink" href="#leetcode" title="Permanent link">&para;</a></h1>
<h2 id="_1">知识学习<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<h3 id="cstl">C++STL容器学习<a class="headerlink" href="#cstl" title="Permanent link">&para;</a></h3>
<h4 id="vector">vector<a class="headerlink" href="#vector" title="Permanent link">&para;</a></h4>
<ul>
<li>变长数组</li>
<li>访问：下表or迭代器</li>
<li>函数：</li>
<li>push_back()</li>
<li>pop_back()</li>
<li>size()</li>
<li>clear() O(N)</li>
<li>insert(it, x) O(N)</li>
<li>erase(it)</li>
<li>常用函数</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="n">a</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="n">a</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<h4 id="string">string<a class="headerlink" href="#string" title="Permanent link">&para;</a></h4>
<ul>
<li>字符串加强版，减少对指针的依赖，集成了一些操作</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;abcd&quot;</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">str</span><span class="p">;</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">str</span><span class="p">;</span><span class="w"></span>
<span class="n">string</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">string</span><span class="w"> </span><span class="n">str2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;opq&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">str</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">str2</span><span class="p">);</span><span class="c1">//输出“abcopqd”</span>
<span class="n">str</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">str2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">str2</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">//将另一个str中的某一部分查到指定位置 末尾是指最后一个字符的下一个</span>
<span class="n">str</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="n">str</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">brgin</span><span class="p">(),</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="n">str</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>
<span class="n">string</span><span class="w"> </span><span class="n">str1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str2</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<span class="n">str1</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span><span class="c1">//寻找匹配的子串第一次出现的pos，否则返回string::npos</span>
</code></pre></div>
<h4 id="stack">stack<a class="headerlink" href="#stack" title="Permanent link">&para;</a></h4>
<h4 id="queue">queue<a class="headerlink" href="#queue" title="Permanent link">&para;</a></h4>
<ul>
<li>队列 FIFO </li>
<li>函数：</li>
<li>push()</li>
<li>pop()</li>
<li>front() back()</li>
<li>bool empty()</li>
<li>size()</li>
<li>用途：BFS </li>
<li><mark>注意点</mark>：使用 front() back() pop() 前，必须用empty()判断队列是否为空</li>
</ul>
<h4 id="priority_queue">priority_queue<a class="headerlink" href="#priority_queue" title="Permanent link">&para;</a></h4>
<ul>
<li>优先队列 用 **堆**实现， 队首元素一定是当前队列中优先级最高的那个。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;queue&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">q</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">q_less</span><span class="c1">//less&lt;int&gt; 表示数字大的优先级越大，即数字越来越小</span>
<span class="w">    </span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">q_great</span><span class="c1">// greater&lt;int&gt; 表示数字小的优先级越大，即数字越来越大</span>
<span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">top</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>
<p><mark>注：在使用top()函数前，必须用empty()判断优先队列是否为空</mark></p>
</li>
<li></li>
</ul>
<h4 id="set-unordered_set">set (unordered_set)<a class="headerlink" href="#set-unordered_set" title="Permanent link">&para;</a></h4>
<ul>
<li>set 内部==自动有序==（unordered_set不排序） 不含重复元素</li>
<li>访问 迭代器（地址）</li>
<li>函数</li>
<li>insert() O(logN) </li>
<li>find() O(logN)</li>
<li>erase() way1: erase(it) O(1) way2: erase(value) O(logN) //也可以erase(it, st.end())实现删除一段元素</li>
<li>size() O(1)</li>
<li>clear() O(N)</li>
<li>主要用处：自动去重&amp;&amp;按升序排序 </li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">st</span><span class="p">;</span><span class="w"></span>

<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">st</span><span class="p">;</span><span class="w"></span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="p">(</span><span class="n">it</span><span class="p">;</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<h4 id="map">map<a class="headerlink" href="#map" title="Permanent link">&para;</a></h4>
<ul>
<li>映射：map可以将任何基本类型（包括STL容器）映射到任何基本类型，例如 建立string -&gt; int 的映射</li>
<li>另一种情形：判断给定的一些数字是否在某个文件中出现过。按照正常思路，可以开一个bool类型的hashTable[max_size]，但是当这些数字很大时（例如几千位）这个数组就会开不了。而这时map可以派上用场。将这些数字转换为字符串，然后建立string -&gt; int 的映射（或是直接建立int -&gt; int 的映射）。</li>
<li>访问：和访问普通数组是一样的。但是需要注意，<strong>map中的键是唯一的</strong>，多次的重复输入将会覆盖之前的value。也可以使用迭代器。</li>
<li><mark>map会以键从小到大的顺序自动排序</mark>（同样因为其是用红黑树实现的）</li>
<li>函数：</li>
<li>find(key) O(logN) 返回地址</li>
<li>erase(it) O(1) || erase(key) O(logN) || erase(first, last) 注意last为==区间末尾迭代器的下一个元素==（美国人喜欢左闭右开）</li>
<li>size() O(1)</li>
<li>
<p>clear() O(N)</p>
</li>
<li>
<p>用途：任意类型映射 大整数 每个key对应的val唯一（否则用multimap）</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">//map&lt;keyTypeName, valTypeName&gt; mp;//两个类型：key -&gt; val</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mp</span><span class="p">;</span><span class="w"></span>
<span class="n">mp</span><span class="p">[</span><span class="sc">&#39;m&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"></span>
<span class="n">mp</span><span class="p">[</span><span class="sc">&#39;r&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span><span class="w"></span>
<span class="n">mp</span><span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">40</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mp</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="c1">//输出 a 40 // m 20 // r 30  </span>
</code></pre></div>
<h4 id="pair">pair<a class="headerlink" href="#pair" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">&#39;&#39;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="list">list<a class="headerlink" href="#list" title="Permanent link">&para;</a></h4>
<h3 id="algorithm">algorithm头文件下的常用函数<a class="headerlink" href="#algorithm" title="Permanent link">&para;</a></h3>
<h4 id="sort">sort()函数的用法<a class="headerlink" href="#sort" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="c1">//sort(首元素的地址, 尾元素地址的下一个地址, 比较函数(非必填))</span>
<span class="cm">/*bool cmp(比较对象元素的类型 a, b) {</span>
<span class="cm">    return 符合排序要求的返回true;</span>
<span class="cm">}</span>
<span class="cm">*/</span><span class="w"></span>
<span class="c1">//对于int 类型数据的排序</span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">};</span><span class="w"></span>
<span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">cmp_int</span><span class="p">);</span><span class="c1">//默认升序</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">cmp_int</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//对于char 类型的排序</span>
<span class="kt">int</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">s</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;c&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;b&#39;</span><span class="p">};</span><span class="w"></span>
<span class="n">sort</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">cmp_char</span><span class="p">);</span><span class="c1">//默认字典序</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">cmp_char</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//对于struct 的排序</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="n">stru</span><span class="p">;</span><span class="w"></span>
<span class="n">stru</span><span class="w"> </span><span class="n">struc</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="c1">//省略初始化内容</span>
<span class="n">sort</span><span class="p">(</span><span class="n">struc</span><span class="p">,</span><span class="w"> </span><span class="n">struc</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">cmp_struct</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">cmp_struct</span><span class="p">(</span><span class="n">stru</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">stru</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//对vector&lt;int&gt; 的排序</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">cmp_vector</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">cmp_vector</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="c1">//注意!:因为vector中的元素类型为int</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">vv</span><span class="p">;</span><span class="w"></span>
<span class="c1">//省略初始化</span>
<span class="n">sort</span><span class="p">(</span><span class="n">vv</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">vv</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">cmp_vvector</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">vvector</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="c1">//首先以首元素排序,其次以第二元素排序</span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//对string 类型排序</span>
<span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;bbbb&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;cc&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;aaa&quot;</span><span class="p">};</span><span class="w"></span>
<span class="n">sort</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">cmp_str</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">cmp_str</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">();</span><span class="c1">//按字符串长度排序</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><mark>注意：在类中定义cmp函数时要加**static**</mark></p>
<h4 id="stable_sort">stable_sort用法<a class="headerlink" href="#stable_sort" title="Permanent link">&para;</a></h4>
<p>stable_sort是稳定排序，而sort是不稳定排序，即相同元素的先后顺序在排序前后可能会发生变化。</p>
<ul>
<li>时间复杂度：<span class="arithmatex"><span class="MathJax_Preview">O(NlogN) \sim O(N(logN)^2)</span><script type="math/tex">O(NlogN) \sim O(N(logN)^2)</script></span></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="c1">     // std::cout</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span><span class="c1">    // std::stable_sort</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span><span class="c1">       // std::vector</span><span class="cp"></span>
<span class="c1">//以普通函数的方式实现自定义排序规则</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">mycomp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//以函数对象的方式实现自定义排序规则</span>
<span class="k">class</span><span class="w"> </span><span class="nc">mycomp2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myvector</span><span class="p">{</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">71</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">45</span><span class="p">,</span><span class="w"> </span><span class="mi">26</span><span class="p">,</span><span class="w"> </span><span class="mi">80</span><span class="p">,</span><span class="w"> </span><span class="mi">53</span><span class="p">,</span><span class="w"> </span><span class="mi">33</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="c1">//调用第一种语法格式，对 32、71、12、45 进行排序</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"> </span><span class="c1">//(12 32 45 71) 26 80 53 33</span>
<span class="w">    </span><span class="c1">//调用第二种语法格式，利用STL标准库提供的其它比较规则（比如 greater&lt;T&gt;）进行排序</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span><span class="w"> </span><span class="c1">//(71 45 32 12) 26 80 53 33</span>
<span class="w">    </span><span class="c1">//调用第二种语法格式，通过自定义比较规则进行排序,这里也可以换成 mycomp2()</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">mycomp</span><span class="p">);</span><span class="c1">//12 26 32 33 45 53 71 80</span>
<span class="w">    </span><span class="c1">//输出 myvector 容器中的元素</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="lower_bound-upper_bound">lower_bound &amp; upper_bound()<a class="headerlink" href="#lower_bound-upper_bound" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>lower_bound( )和upper_bound( )都是利用==二分查找==的方法在一个**排好序**的数组中进行查找的。</p>
</li>
<li>
<p>lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到-返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
</li>
<li>
<p>upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lower_bound</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="err">\\</span><span class="w"> </span><span class="n">返回第一个大于等于val的迭代器</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">upper_bound</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="err">\\</span><span class="n">返回第一个大于val的迭代器</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lower_bound</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="err">\\</span><span class="n">返回的是下标</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span><span class="w"></span>


<span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxn</span><span class="o">=</span><span class="mi">100000</span><span class="o">+</span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">INF</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="kt">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="cp">#define LL long long</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">cmd</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">&gt;</span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">34</span><span class="p">};</span><span class="w"> </span>
<span class="w">    </span><span class="n">sort</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">num</span><span class="o">+</span><span class="mi">6</span><span class="p">);</span><span class="w">                           </span><span class="c1">//按从小到大排序 </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">pos1</span><span class="o">=</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">num</span><span class="o">+</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span><span class="o">-</span><span class="n">num</span><span class="p">;</span><span class="w">    </span><span class="c1">//返回数组中第一个大于或等于被查数的值 </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">pos2</span><span class="o">=</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">num</span><span class="o">+</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span><span class="o">-</span><span class="n">num</span><span class="p">;</span><span class="w">    </span><span class="c1">//返回数组中第一个大于被查数的值</span>
<span class="w">    </span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">pos1</span><span class="o">&lt;&lt;</span><span class="s">&quot; &quot;</span><span class="o">&lt;&lt;</span><span class="n">num</span><span class="p">[</span><span class="n">pos1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">pos2</span><span class="o">&lt;&lt;</span><span class="s">&quot; &quot;</span><span class="o">&lt;&lt;</span><span class="n">num</span><span class="p">[</span><span class="n">pos2</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">sort</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">num</span><span class="o">+</span><span class="mi">6</span><span class="p">,</span><span class="n">cmd</span><span class="p">);</span><span class="w">                      </span><span class="c1">//按从大到小排序</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">pos3</span><span class="o">=</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">num</span><span class="o">+</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">())</span><span class="o">-</span><span class="n">num</span><span class="p">;</span><span class="w">  </span><span class="c1">//返回数组中第一个小于或等于被查数的值 </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">pos4</span><span class="o">=</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">num</span><span class="o">+</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">())</span><span class="o">-</span><span class="n">num</span><span class="p">;</span><span class="w">  </span><span class="c1">//返回数组中第一个小于被查数的值 </span>
<span class="w">    </span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">pos3</span><span class="o">&lt;&lt;</span><span class="s">&quot; &quot;</span><span class="o">&lt;&lt;</span><span class="n">num</span><span class="p">[</span><span class="n">pos3</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">pos4</span><span class="o">&lt;&lt;</span><span class="s">&quot; &quot;</span><span class="o">&lt;&lt;</span><span class="n">num</span><span class="p">[</span><span class="n">pos4</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">   </span>
<span class="p">}</span><span class="w"> </span>
</code></pre></div>
<h3 id="_2">数据结构<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<h4 id="_3">链表<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h4>
<h4 id="_4">树<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<ul>
<li>概念：<span class="arithmatex"><span class="MathJax_Preview"><span class="arithmatex"><span class="MathJax_Preview">node\ leaf\ edge\ child\ subtree</span><script type="math/tex">node\ leaf\ edge\ child\ subtree</script></span></span><script type="math/tex"><span class="arithmatex"><span class="MathJax_Preview">node\ leaf\ edge\ child\ subtree</span><script type="math/tex">node\ leaf\ edge\ child\ subtree</script></span></script></span></li>
<li>度（degree）：子树的棵树//最大值为树的度</li>
<li>由于一条边连接两个节点，且树中不存在环，因此对有n个节点的树，边数一定是n - 1。且满足**连通、边数= 顶点数 - 1的结构一定是一棵树**。</li>
<li>叶子节点：度为0的节点</li>
<li>深度（depth）：自顶向下    高度（height）：自底向上</li>
<li>完全二叉树：满二叉树+只能是右子节点不存在</li>
<li><mark>注意：新建树/节点后必须初始化其左右子节点的地址为NULL</mark></li>
</ul>
<h5 id="_5">树的遍历<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>前序遍历（preorder）：根-左-右</p>
</li>
<li>
<p>判断当前节点是否为NULL</p>
</li>
<li>访问根节点</li>
<li>递归左子节点</li>
<li>
<p>递归右子节点</p>
</li>
<li>
<p>中序遍历（inorder）：左-根-右</p>
</li>
<li>
<p>后序遍历（postorder）：左-右-根</p>
</li>
<li>
<p>层序遍历（layerOrder）：</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">TreeNode</span><span class="w"> </span><span class="n">TreeNode</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">TreeNode</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">TreeNode</span><span class="w"> </span><span class="o">*</span><span class="n">left</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TreeNode</span><span class="w"> </span><span class="o">*</span><span class="n">right</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">q</span><span class="p">;</span><span class="w"></span>
<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span><span class="w"></span>
<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">TreeNode</span><span class="w"> </span><span class="o">*</span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">right</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h5 id="bst">BST 二叉搜索树<a class="headerlink" href="#bst" title="Permanent link">&para;</a></h5>
<ul>
<li>定义：左子树上所有节点的数据域均小于或等于根节点的数据域，右子树上所有节点的数据域均大于根节点的数据域。</li>
<li>查找：有点类似二分查找：<strong>左子树&lt;=根节点&lt;右子树</strong></li>
<li>插入：基于查找</li>
<li>性质：对二叉查找树进行中序遍历，遍历的结果是有序的。</li>
</ul>
<h5 id="avl">AVL树 平衡二叉树<a class="headerlink" href="#avl" title="Permanent link">&para;</a></h5>
<h5 id="_6">并查集<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h5>
<ul>
<li>合并：合并两个集合，先判断是否为同一个集合，若不是，则把其中一个根节点的父节点指向另一个集合的根节点</li>
<li>查找：判断两个元素是否在同一个集合</li>
<li>代码实现：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">father</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="c1">//father[i]表示元素i的父节点，若father[i] == i，则说明i为集合的根节点，作为所属集合的标识</span>
<span class="c1">//initialize</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">//or father[i] = -1</span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//find</span>
<span class="kt">int</span><span class="w"> </span><span class="n">findFather</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">father</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">father</span><span class="p">[</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//findRecursive</span>
<span class="kt">int</span><span class="w"> </span><span class="n">findFatherR</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">father</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">findFatherR</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//union</span>
<span class="kt">void</span><span class="w"> </span><span class="k">union</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">faA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">findFather</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">faB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">findFather</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">faA</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">faB</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">father</span><span class="p">[</span><span class="n">faB</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">faA</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h6 id="_7">路径压缩<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h6>
<p>把当前查询节点的路径上的所有节点的父节点都指向根节点，使得查找时不必一直回溯，查询的复杂度可以降到O(1)。</p>
<p>因此转换的过程可以概括为：</p>
<ol>
<li>按原先的写法获得x的根节点r</li>
<li>重新从x开始走一遍寻找根节点的过程，把路径上经过的所有节点的父节点都改为根节点。</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">findFather</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">remark</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">father</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">father</span><span class="p">[</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">remark</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">father</span><span class="p">[</span><span class="n">remark</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">father</span><span class="p">[</span><span class="n">remark</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">father</span><span class="p">[</span><span class="n">remark</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">remark</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h5 id="_8">字典树<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h5>
<p>​ 实现前缀匹配，模糊搜索。可以快速的插入和查找</p>
<h5 id="_9">哈夫曼树（最优二叉树）<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h5>
<p>路径长度：从根节点出发到达该节点所经过的边数。</p>
<p>带权路径长度（weighed path length of tree）：<span class="arithmatex"><span class="MathJax_Preview"><span class="arithmatex"><span class="MathJax_Preview">\sum(叶子节点的权值\times路径长度)</span><script type="math/tex">\sum(叶子节点的权值\times路径长度)</script></span></span><script type="math/tex"><span class="arithmatex"><span class="MathJax_Preview">\sum(叶子节点的权值\times路径长度)</span><script type="math/tex">\sum(叶子节点的权值\times路径长度)</script></span></script></span></p>
<p><strong>哈夫曼树的构建思路</strong>：每次合并节点权值最小的两个节点，合并后的节点放回，进行下一次的比较。（图示见下）</p>
<p><img alt="img" src="https://yunzinan-pic-bed.oss-cn-nanjing.aliyuncs.com/2022/05/1468796-20190305104828864-176580657.png" /></p>
<p>性质：哈夫曼树不存在度为1的节点，并且权值越高的节点相对来说越接近根节点。</p>
<p>哈夫曼编码：可变长编码 减少编码长度</p>
<ol>
<li>
<p><a href="https://www.cnblogs.com/liuzeyu12a/p/10475980.html">最优二叉树(赫夫曼树) - 四季列车 - 博客园 </a></p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/BV18V411v7px">【算法】Huffman编码</a></p>
</li>
</ol>
<h4 id="_10">栈<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h4>
<h4 id="_11">队列<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<h4 id="_12">树状数组<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h4>
<blockquote>
<blockquote>
<p>引入：考虑一个单点修改、区间求和的问题。</p>
<p>若采用朴素算法，</p>
<p>​   单点修改：O(1)</p>
<p>​   区间查询：O(N)</p>
<p>若采用前缀和，</p>
<p>​   单点修改：O(N)</p>
<p>​   区间查询：O(1) </p>
</blockquote>
</blockquote>
<p>引入树状数组，使得修改和查询的复杂度都为O(logN)</p>
<h5 id="lowbit">预备知识：lowbit()运算<a class="headerlink" href="#lowbit" title="Permanent link">&para;</a></h5>
<p>非负整数 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> <mark>在二进制表示下最低位 1 及其后面的 0 构成的数值</mark>
$$
\begin{aligned}
\sim n+1=-n &amp;(\sim \text { 表示取反 }) \
\operatorname{lowbit}(n) &amp;=n \&amp;(\sim n+1) \
&amp;=n \&amp;-n
\end{aligned}
$$
<img alt="image-20220404144542976" src="https://yunzinan-pic-bed.oss-cn-nanjing.aliyuncs.com/2022/05/image-20220404144542976.png" /></p>
<p>树状数组的性质</p>
<ul>
<li>
<div class="arithmatex">
<div class="MathJax_Preview">
  c[x]存储(x-lowbit(x),x]的和
  </div>
<script type="math/tex; mode=display">
  c[x]存储(x-lowbit(x),x]的和
  </script>
</div>
</li>
<li>
<p><code>c++
  int sum = 0;
  for(int i = x; i &gt; 0; i -= lowbit(i)) {
      sum += c[i];
  }</code></p>
</li>
<li></li>
</ul>
<h4 id="_13">哈希（散列）<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h4>
<ul>
<li>definition: Hash Table is a data structure to map key to values (also called Table or Map Abstract Data Type/ADT). It uses a <strong>hash function</strong> to map large or even non-Integer keys into a small range of Integer indices (typically [0..hash_table_size-1]).</li>
</ul>
<p>The probability of two distinct keys colliding into the same index is <a href="https://visualgo.net/zh/hashtable?slide=3-5">relatively high</a> and each of this potential collision needs to be resolved to maintain <mark>data integrity</mark>（数据可靠性）.</p>
<p>There are several collision resolution strategies that will be highlighted in this visualization: Open Addressing (Linear Probing, Quadratic Probing, and Double Hashing) and Closed Addressing (Separate Chaining).</p>
<p>[来源]（<a href="https://visualgo.net/zh/hashtable?slide=1">哈希表（开放寻址法：线性探测，二次探测，双倍散列 以及 闭散列分离连接法） - VisuAlgo</a>）</p>
<ul>
<li>
<p>哈希的本质是一个数组：</p>
</li>
<li>
<p>数组+链表</p>
</li>
<li>
<p>数组+BST(冲突比较多时，降低存储效率以换取查找效率)</p>
</li>
<li>
<p>哈希冲突的解决方法：</p>
</li>
<li>
<p>拉链法</p>
</li>
<li>
<p>开放寻址法</p>
</li>
<li>
<p>哈希的核心是哈希函数</p>
</li>
<li>
<p>如何理解哈希表？（hashTable）</p>
</li>
<li>
<p>例：QQ群列表里找某个人？逐个找（遍历）？太慢！</p>
</li>
<li>策略：按照昵称首字母a-z排序，例如昵称为Jack_shen的，直接在<span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>中查找即可。</li>
<li>
<p>注意到这里我们对输入的数据（Jack_shen）进行了某种运算（取首字母），得到了对应的key(<span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>)，相当于将所有的输入的字符串分为26个堆来存放，这样查找时根据这个算法再次计算得到其所在的key，只需在这个堆中进行遍历即可。</p>
</li>
<li>
<p>键值对：一个值对应另外一个值（key -&gt; value）key叫做键值，value叫做哈希值</p>
</li>
<li>
<p>如何理解哈希映射？（hashMap）</p>
</li>
</ul>
<h4 id="_14">优先队列（堆）<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h4>
<ul>
<li>优先队列（priority queue）。实现的功能就是**取出一堆数字中的最大数或者最小数**，以最小数放在堆顶为例，如果维护一个链表，那么添加元素的复杂度为O（1），但是查找元素的复杂度为O（N），我们必须遍历链表的每一个元素才可以找到其中的最小值；如果维护一个普通的单调数组，这样的话插入的复杂度为O（N），查找的复杂度为O(1)，所以一种折衷的方案是使用高度平衡的二叉树，由于其结构完全确定，我们其实可以只用一个数组来储存，但并不破坏其二叉树的本质。</li>
</ul>
<p>令数组下标从1开始，会有1|2 3|4 5 6 7|... 父节点到子节点有这样的关系：
  $$
  root&amp;x\ leftLeaf&amp;2x\ rightLeaf&amp;2x+1
  $$</p>
<ul>
<li></li>
</ul>
<p>​       所以我们可以据此推断出任意一个节点的父节点和子节点。</p>
<ul>
<li>堆的添加元素</li>
</ul>
<p><img alt="image-20220217223136977" src="https://yunzinan-pic-bed.oss-cn-nanjing.aliyuncs.com/2022/05/image-20220217223136977.png" /></p>
<ul>
<li>堆的删除元素</li>
</ul>
<p><img src="https://yunzinan-pic-bed.oss-cn-nanjing.aliyuncs.com/2022/05/image-20220217223412247.png" alt="image-20220217223412247" style="zoom:33%;" /></p>
<ul>
<li>实现代码</li>
</ul>
<h4 id="_15">图<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>图的属性：</p>
</li>
<li>
<p>边（edge）：有向图/无向图、边权</p>
</li>
<li>
<p>点（vertex）：出度/入度、边权</p>
</li>
<li>
<p><mark>注</mark>：图的抽象：边就是“关系”，点就是“状态”</p>
</li>
<li>
<p><strong>连通分量</strong>：在**无向图**中，如果两个顶点之间可以相互到达，那么就称这两个顶点连通。如果图中任意两个顶点都连通，则称为连通图；否则成为非连通图，其中，极大的连通子图为连通分量。</p>
</li>
<li>
<p><strong>强连通分量</strong>：在**有向图**中，如果两个顶点可以各自通过一条有向路径到达另一个顶点，那么九称这两个顶点强连通。如果任意两点都强连通，则称为强连通图，否则，称为非强连通图，其中极大强连通子图为强连通分量。</p>
</li>
<li>
<p>为了叙述的方便，将连通分量和强连通分量称为**连通块**。</p>
</li>
</ul>
<h5 id="_16">图的存储：<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h5>
<ul>
<li>邻接表</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">graph</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="c1">//if(graph[i][j] == n) it means that i-j has an edge with the value of n</span>
</code></pre></div>
<p>​    </p>
<ul>
<li>邻接矩阵</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">//usually implemented by Node List or vector</span>
</code></pre></div>
<h2 id="-">- 链式前向星<a class="headerlink" href="#-" title="Permanent link">&para;</a></h2>
<h5 id="dfs">图的遍历：深搜（DFS）<a class="headerlink" href="#dfs" title="Permanent link">&para;</a></h5>
<div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>- 每次总是沿着路径到不能再前进时才退回到最近的岔道口

- 具体实现：
</code></pre></div></td></tr></table></div>

<div class="highlight"><pre><span></span><code>```c++
//pseudo
DFS(u) {//visit vertex u
    vis[u] = true;
    for(从u出发能到达的所有顶点v) {
        if(vis[v] == false) {
            DFS(v);
        }
    }
}
DFSTrave(G) {// traverse G
    for(G的所有顶点u) {
        if(vis[u] == false) {
            DFS(u);
        }
    }
}
//邻接矩阵版
#define MAXV 1000
#define INF 1000000000
int n, G[MAXV][MAXV];
bool vis[MAXV] = {false};

void DFS(int u, int depth) {
    vis[u] = true;
    for(int v = 0; v &lt; n; v++) {
        if(vis[v] == false &amp;&amp; G[u][v] != INF) {
            DFS(v,depth+1);
        }
    }
}

void DFSTrave() {
    for(int u = 0; u &lt; n; u++) {
        if(vis[u] == false) {
            DFS(u, 1);
        }
    }
}
//邻接表版
vector&lt;int&gt; adj[MAXV];
int n;
bool vis[MAXV] = {false};

void DFS(int u, int depth) {
    vis[u] = true;
    for(int i = 0; i &lt; adj.size(); i++) {
        int v = adj[u][i];
        if(vis[v] == false) {
            DFS(v, depth+1);
        }
    }
}

void DFSTrave() {
    for(int u = 0; u &lt; n; u++) {
        if(vis[u] == false) {
            DFS(u,1)
        }
    }
}
```
</code></pre></div>
<p>​      </p>
<h5 id="bfs">图的遍历：广搜（BFS）<a class="headerlink" href="#bfs" title="Permanent link">&para;</a></h5>
<h5 id="aa">图的遍历：<span class="arithmatex"><span class="MathJax_Preview">A^*</span><script type="math/tex">A^*</script></span>算法<a class="headerlink" href="#aa" title="Permanent link">&para;</a></h5>
<p><a href="https://www.bilibili.com/video/BV1bv411y79P?spm_id_from=333.337.search-card.all.click">A*寻路算法详解 #A星 #启发式搜索_哔哩哔哩_bilibili</a></p>
<h5 id="minimal-spanning-tree-prim">最小生成树 (Minimal Spanning Tree) ：prim算法<a class="headerlink" href="#minimal-spanning-tree-prim" title="Permanent link">&para;</a></h5>
<blockquote>
<blockquote>
<p><strong>Tree vs. Graphs</strong></p>
<p>1) Trees are undirected graphs. 
2) Trees do not have circles(acyclic).</p>
<p>So, how to turn a graph into a tree?</p>
<ul>
<li>Keep all the n vertices.</li>
<li>Keep exactly n-1 edges.(not connected if less, has circle(s) if more.)</li>
<li>It's impossible to turn a disconnected graph into a tree.</li>
</ul>
</blockquote>
</blockquote>
<ul>
<li>
<p>Definition of MST: the spanning tree with the minimum sum of weights.</p>
</li>
<li>
<p><strong>Basic idea: grow the tree in successive stages.</strong></p>
</li>
<li>In each iteration, add one vertex and one edge to the tree.</li>
<li>Thoroghout, maintain the properties of trees.</li>
<li>Connectivity</li>
<li>No circle</li>
<li>The algorithm runs in <span class="arithmatex"><span class="MathJax_Preview">|V|</span><script type="math/tex">|V|</script></span> iterations.</li>
<li>Maintenance:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">selected</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="c1">//place all the vertices that has alreay been linked.</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">unselected</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="c1">//temporally not selected vertices</span>
</code></pre></div>
<ul>
<li>
<p>Procedures:</p>
</li>
<li>
<p>Update</p>
<p>Update all the vertices that the current vertex is connected to, if </p>
</li>
<li>
<p>Scan</p>
</li>
<li>
<p>Add</p>
</li>
</ul>
<h5 id="mstkruskal">最小生成树（MST）：Kruskal算法<a class="headerlink" href="#mstkruskal" title="Permanent link">&para;</a></h5>
<h5 id="dijkstra">单源最短路径：Dijkstra算法<a class="headerlink" href="#dijkstra" title="Permanent link">&para;</a></h5>
<p><a href="https://www.youtube.com/watch?v=EFg3u_E6eHU">How Dijkstra's Algorithm Works - YouTube</a></p>
<ul>
<li>
<p>思路：可以证明，路径<span class="arithmatex"><span class="MathJax_Preview">P_i\rightarrow ...\rightarrow P_k\rightarrow ...\rightarrow  P_j</span><script type="math/tex">P_i\rightarrow ...\rightarrow P_k\rightarrow ...\rightarrow  P_j</script></span>的最短路径为从i到k的最短路径+从k到j的最短路径，因此要想找到从i到j的最短路径，需要依次找到到其之前各节点的最段路径。</p>
</li>
<li>
<p>维护：</p>
</li>
<li>vis[n] 将所有的节点分为“已找到最短路径的节点”和“尚未找到的”，后者不断转化为前者</li>
<li>dis[n] 表示在当前阶段 从源节点到i的最短路径</li>
<li>fa[n] 表示这条“当前最优”的路径下i的前一个节点</li>
<li>步骤：</li>
<li>初始化（建立邻接表、初始化几个维护的数组、fa[src] = src, vis[src] = true, dis[src] = 0）</li>
<li>循环USA(for int t = 1; t &lt; vertices.size(); i++) <ul>
<li>Update 更新当前节点能到达的所有尚未找到最短路径的点的最短路径（如果更短的话），这一步维护dis[n] fa[n]</li>
<li>Scan 找到所有尚未找到最短路径的节点中距离最短的点</li>
<li>Add 这个点的当前最段路径必为最短路径，因此将其加入“已经找到最短路径”的集合中，这一步维护 vis[n]</li>
</ul>
</li>
</ul>
<h5 id="_17">拓扑排序<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h5>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247489706&amp;idx=1&amp;sn=771cd807f39d1ca545640c0ef7e5baec">【拓扑排序】图论拓扑排序入门 (qq.com)</a></p>
<p>Directed Acyclic Graphs(DAG)
The only type of graph which has a valid topological ordering is a Directed Acyclic Graph (DAG). These are graphs with directed edges and no cycles.</p>
<p>Q: How do I verify that my graph does not contain a directed cycle?</p>
<p>A: One method is to use Tarjan's strongly connected component algorithm which can be used to find these cycles.</p>
<blockquote>
<blockquote>
<p>拓扑排序实际上应用的是贪心算法。贪心算法简而言之：每一步最优，全局就最优。</p>
<p>具体到拓扑排序，每一次都从图中删除没有前驱的顶点，这里并不需要真正的做删除操作，我们可以设置一个入度数组，每一轮都输出入度为 00 的结点，并移除它、修改它指向的结点的入度（-1−1即可），依次得到的结点序列就是拓扑排序的结点序列。如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。</p>
<p>拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面，并且可以完成所有活动。拓扑排序的结果不唯一。拓扑排序还可以用于检测一个有向图是否有环。相关的概念还有 AOV 网，这里就不展开了。</p>
<p>算法流程：</p>
<p>1、在开始排序前，扫描对应的存储空间（使用邻接表），将入度为 00 的结点放入队列。</p>
<p>2、只要队列非空，就从队首取出入度为 00 的结点，将这个结点输出到结果集中，并且将这个结点的所有邻接结点（它指向的结点）的入度减 11，在减 11 以后，如果这个被减 11 的结点的入度为 00 ，就继续入队。</p>
<p>3、当队列为空的时候，检查结果集中的顶点个数是否和课程数相等即可。</p>
<p>思考这里为什么要使用队列？（马上就会给出答案。）</p>
<p>在代码具体实现的时候，除了保存入度为 0 的队列，我们还需要两个辅助的数据结构：</p>
<p>1、邻接表：通过结点的索引，我们能够得到这个结点的后继结点；</p>
<p>2、入度数组：通过结点的索引，我们能够得到指向这个结点的结点个数。</p>
<p>这个两个数据结构在遍历题目给出的邻边以后就可以很方便地得到。</p>
</blockquote>
</blockquote>
<h5 id="tarjan">强连通分量求法：Tarjan算法<a class="headerlink" href="#tarjan" title="Permanent link">&para;</a></h5>
<p>[<a href="https://www.bilibili.com/video/BV19J411J7AZ?p=3">算法]轻松掌握tarjan强连通分量_哔哩哔哩_bilibili</a></p>
<h5 id="_18">图中是否存在环的判断<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h5>
<ul>
<li>有向图：拓扑排序</li>
<li>无向图：并查集</li>
</ul>
<h3 id="_19">算法<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<h4 id="_20">排序和搜索<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h4>
<h4 id="_21">二分查找<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h4>
<ul>
<li>利用二分对象的**单调性**， 每次查找将查询空间折半，使得复杂度为O(logN)</li>
<li>二分的难点不在于实现，而是想到要二分，想到对谁进行二分，要利用好这个单调性。</li>
</ul>
<h4 id="dp">dp<a class="headerlink" href="#dp" title="Permanent link">&para;</a></h4>
<blockquote>
<blockquote>
<p>我们是如何确定本题可以使用动态规划来解诀的?
 通常我们要从「有无后效性」进行入手分析。
 如果对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话，那么这就是一个无后效性 的问题，可以考虑使用 DP 解决。
 另外一个更加实在的技巧，我们还可以通过 数据范围来猜测是不是可以用 DP 来做。
 因为 DP 是一个递推的过程，因此如果数据范围是 <span class="arithmatex"><span class="MathJax_Preview">10^{5} \sim 10^{6}</span><script type="math/tex">10^{5} \sim 10^{6}</script></span> 的话，可以考虑是不是可以使用一维 DP 来解决；如果 数据范围是 <span class="arithmatex"><span class="MathJax_Preview">10^{2} \sim 10^{3}</span><script type="math/tex">10^{2} \sim 10^{3}</script></span> 的话，可以考虑是不是可以使用二维 DP 来做 ...</p>
<p>我们是如何确定本题的状态定义的?
 说实话，DP 的状态定义很大程度是靠经验去猜的。
 虽然大多数情况都是猜的，但也不是毫无规律，相当一部分题目的状态定义是与「结尾」或「答案」有所关联的。</p>
</blockquote>
<p><a href="https://leetcode-cn.com/leetbook/read/path-problems-in-dynamic-programming/rtd7d2/">DP - 路径问题 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p>
</blockquote>
<h4 id="_22">蓄水池抽样<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h4>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247490892&amp;idx=1&amp;sn=c1fe373edc88142cbabd383ef3c0669b">【蓄水池抽样】多语言入门蓄水池抽样</a></p>
<p>整理题意：总的样本数量末知, 从所有样本中抽取若干个，要求每个样本被抽到的概率相等。
具体做法为: 从前往后处理每个样本, 每个样本成为答案的概率为 <span class="arithmatex"><span class="MathJax_Preview">\frac{1}{i}</span><script type="math/tex">\frac{1}{i}</script></span>, 其中 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 为样本编号 (编号从 1 开始), 最终可以确保每个样本成为答案的概率均为 <span class="arithmatex"><span class="MathJax_Preview">\frac{1}{n}</span><script type="math/tex">\frac{1}{n}</script></span> (其中 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 为样本总 数）。
容易证明该做法的正确性, 假设最终成为答案的样本编号为 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>, 那么 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 成为答案的充要条件 为「在遍历到 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 时被选中」并且「遍历大于 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 的所有元素时, 均没有被选择（没有覆盖 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> ) <span class="arithmatex"><span class="MathJax_Preview">\perp 。</span><script type="math/tex">\perp 。</script></span>
对应事件概率为:
$$
P=\frac{1}{k} *\left(1-\frac{1}{k+1}\right) *\left(1-\frac{1}{k+2}\right) * \ldots *\left(1-\frac{1}{n}\right)
$$
首项 <span class="arithmatex"><span class="MathJax_Preview">\frac{1}{k}</span><script type="math/tex">\frac{1}{k}</script></span> 为选中 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 的概率, 后面每项分别为编号为 <span class="arithmatex"><span class="MathJax_Preview">[k+1, n]</span><script type="math/tex">[k+1, n]</script></span> 的样本「不被选中」的概率。
化简得:
$$
P=\frac{1}{k} * \frac{k}{k+1} * \frac{k+1}{k+2} * \ldots * \frac{n-1}{n}
$$
进一步抵消化简后, 可得:
$$
P=\frac{1}{n}
$$
因此, 在每一次 getrandom 时, 从前往后处理每个节点, 同时记录当前节点的编号, 当处 理到节点 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 时, 在 <span class="arithmatex"><span class="MathJax_Preview">[0, k)</span><script type="math/tex">[0, k)</script></span> 范围内进行随机, 若随机到结果为 0 (发生概率为 <span class="arithmatex"><span class="MathJax_Preview">\frac{1}{k}</span><script type="math/tex">\frac{1}{k}</script></span> ), 则将节点 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 的值存入答案, 最后一次覆盖答案的节点即为本次抽样结果。</p>
<div class="highlight"><pre><span></span><code><span class="c1">//模板</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Solution</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">_head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_head</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">getRandom</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="n">idx</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<p>使用蓄水池算法，用通俗的语言说一下：</p>
<ul>
<li>如果我们池子中只有一个数字，那么拿到第一个数字的概率就是100%毋庸置疑。</li>
<li>两个数字50% 三个数字每个数字的几率都是33% 以此类推。。。。</li>
</ul>
<p>当我们不知道池子里有多少个数字的时候，就需要用蓄水池的算法思想去计算。</p>
<ul>
<li>当链表前行到第一个数字，此时取第一个数字的几率为100%，那result自然等于这个数字。</li>
<li>前进到第二个数字，那么此时取这个数字的几率自然就为50%（池子里只有两个数字），那么就是50%的几率取新数字，50%的几率保留原本的数字。</li>
<li>第三个数字的时候，33%的几率取当前最新的这个数字，66%的几率保留原本的数字。这66%中：原本的数字有50%的几率是1，有50%的几率是2。也就是此时三个数字的概率都为33%。 通过这个算法，就能达到取数的概率均摊，从而实现随机。</li>
</ul>
<h2 id="_23">刷题记录（补充知识+做题经验）<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h2>
<h4 id="check">二分+check<a class="headerlink" href="#check" title="Permanent link">&para;</a></h4>
<h5 id="lc5219"><a href="https://leetcode-cn.com/problems/maximum-candies-allocated-to-k-children/">LC5219 每个小孩最多能分到多少糖果</a><a class="headerlink" href="#lc5219" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">maximumCandies</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span>
<span class="w">            </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* low分得最少糖果数目，high分得最多糖果数目 */</span><span class="w"></span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">high</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="c1">// 二分糖果数目</span>
<span class="w">            </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">heap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="c1">// 按照每堆糖果数为mid的糖果一共可以分多少堆</span>
<span class="w">            </span><span class="cm">/* 更新堆的个数 */</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span>
<span class="w">               </span><span class="n">heap</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="cm">/* 判断按当前糖果数分的对数和孩子个数进行判断 */</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">heap</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">else</span><span class="w"></span>
<span class="w">                </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">high</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<h4 id="_24">栈<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h4>
<h5 id="lc150">LC150 逆波兰表达式求值<a class="headerlink" href="#lc150" title="Permanent link">&para;</a></h5>
<ul>
<li>逆波兰表达式（Reverse Polish Notation）<span class="arithmatex"><span class="MathJax_Preview"><span class="arithmatex"><span class="MathJax_Preview">e.g.</span><script type="math/tex">e.g.</script></span></span><script type="math/tex"><span class="arithmatex"><span class="MathJax_Preview">e.g.</span><script type="math/tex">e.g.</script></span></script></span><mark>后缀表达式（Suffix Expression）</mark></li>
<li>表达式由操作数（operand）、运算符（operator）组成，一般将运算符放在两个操作数之间，被称为（Infix Expression），如A+B。波兰数学家提出了另一种数学表示法，由两种表示形式：前缀、后缀。</li>
<li>算法：以表达式<span class="arithmatex"><span class="MathJax_Preview">1\times(2+3)</span><script type="math/tex">1\times(2+3)</script></span>为例，维护两个栈：运算符号栈，后缀表达式输出栈。</li>
<li>首先从左至右扫描表达式，遇到操作数直接压入出栈，若读取的为操作数，则按照以下规则压入入栈。</li>
<li><img alt="" src="https://yunzinan-pic-bed.oss-cn-nanjing.aliyuncs.com/2022/05/image-20220210224140687.png" /></li>
<li>​ 整个过程分为两步：1.将中缀表达式转化为后缀表达式（利用入栈）；2。逐步计算后缀表达式（利用出栈）</li>
</ul>
<h4 id="_25">并查集<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h4>
<h5 id="lc547">LC547 省份数量<a class="headerlink" href="#lc547" title="Permanent link">&para;</a></h5>
<p>经典并查集题目，有很多别名（朋友圈、城市连接问题），套模板即可：</p>
<ul>
<li>int findFather() //路径压缩，不做也能过，但是慢一些</li>
<li>void Union()</li>
</ul>
<h5 id="lc1319"><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">LC1319 连通网络的操作次数</a><a class="headerlink" href="#lc1319" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fa</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rk</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vertices</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Union</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index_a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index_b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">root_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index_a</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">root_a</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">root_a</span><span class="p">)</span><span class="w"> </span><span class="n">root_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fa</span><span class="p">[</span><span class="n">root_a</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">root_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index_b</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">root_b</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">root_b</span><span class="p">)</span><span class="w"> </span><span class="n">root_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fa</span><span class="p">[</span><span class="n">root_b</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">root_a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">root_b</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">rk</span><span class="p">[</span><span class="n">root_a</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rk</span><span class="p">[</span><span class="n">root_b</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">rk</span><span class="p">[</span><span class="n">root_a</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">fa</span><span class="p">[</span><span class="n">root_b</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">root_a</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">rk</span><span class="p">[</span><span class="n">root_a</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rk</span><span class="p">[</span><span class="n">root_b</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">fa</span><span class="p">[</span><span class="n">root_a</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">root_b</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">fa</span><span class="p">[</span><span class="n">root_b</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">root_a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="c1">// union with rank</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">Find</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">root</span><span class="p">)</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fa</span><span class="p">[</span><span class="n">root</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">root</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fa</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="n">fa</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">root</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w">   </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">root</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="c1">//compress</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">ini</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">fa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">rk</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">makeConnected</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">connections</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">edgeSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">connections</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">ini</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">cntE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">edgeSize</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">index_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">connections</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">index_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">connections</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">Find</span><span class="p">(</span><span class="n">index_a</span><span class="p">)</span><span class="o">!=</span><span class="w"> </span><span class="n">Find</span><span class="p">(</span><span class="n">index_b</span><span class="p">))</span><span class="w"> </span><span class="n">Union</span><span class="p">(</span><span class="n">index_a</span><span class="p">,</span><span class="w"> </span><span class="n">index_b</span><span class="p">);</span><span class="c1">//***</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="o">++</span><span class="n">cntE</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">cntV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">vertices</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">Find</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">vertices</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">cntV</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">vertices</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Find</span><span class="p">(</span><span class="n">i</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">cntV</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">cntE</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">cntV</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<p><mark>注意：***处不可以写成fa[index_a] == fa[index_b]，原因是在并查集中，即使在一个树中，不同子节点的根节点在Find()之前不一定是相同的！！</mark></p>
<h4 id="_26">二叉树<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h4>
<h5 id="lc889">LC889 根据前序和后序遍历构造二叉树<a class="headerlink" href="#lc889" title="Permanent link">&para;</a></h5>
<p>此题要求对前序、后序遍历有比较深的理解。它们都具有清晰的**递归**结构。需要注意到二叉树的前序、后序遍历**对应在数组中的结构特性**。</p>
<p>前序遍历数组：根节点-树的左半部分-树的右半部分</p>
<p>后序遍历数组：树的左半部分-树的右半部分-根节点</p>
<p>而”树的左/右半部分”又可以视作一棵子树，从而实现递归，直到子数组的长度为1（递归边界）。</p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * Definition for a binary tree node.</span>
<span class="cm"> * struct TreeNode {</span>
<span class="cm"> *     int val;</span>
<span class="cm"> *     TreeNode *left;</span>
<span class="cm"> *     TreeNode *right;</span>
<span class="cm"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span>
<span class="cm"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span>
<span class="cm"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span>
<span class="cm"> * };</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">TreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">constructFromPrePost</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">preorder</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">postorder</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">TreeNode</span><span class="w"> </span><span class="o">*</span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">TreeNode</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">buildTree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">preorder</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">preorder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">postorder</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">root</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">buildTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="w"> </span><span class="o">*</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pre</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">preL</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">preR</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">post</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">postL</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">postR</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">preL</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">preR</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">preL</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">preR</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="c1">//只有一个节点了</span>
<span class="w">            </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pre</span><span class="p">[</span><span class="n">preL</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="c1">//不止一个节点 说明至少存在一个子节点</span>
<span class="w">        </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pre</span><span class="p">[</span><span class="n">preL</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">preL</span><span class="o">++</span><span class="p">;</span><span class="c1">//preL 指向左子节点</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">postR</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">post</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">post</span><span class="p">[</span><span class="n">postR</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pre</span><span class="p">[</span><span class="n">preL</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="c1">//找到左子节点在后序中的位置，该位置前的节点都是其子节点</span>
<span class="w">            </span><span class="n">postR</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="c1">//postR - postL = 左子节点的子节点数</span>
<span class="w">        </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">TreeNode</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">preLR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">preL</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">postR</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">postL</span><span class="p">;</span><span class="c1">//分割点：左区间的右端点</span>
<span class="w">        </span><span class="n">buildTree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">pre</span><span class="p">,</span><span class="w"> </span><span class="n">preL</span><span class="p">,</span><span class="w"> </span><span class="n">preLR</span><span class="p">,</span><span class="w"> </span><span class="n">post</span><span class="p">,</span><span class="w"> </span><span class="n">postL</span><span class="p">,</span><span class="w"> </span><span class="n">postL</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">preL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">preLR</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="c1">//preL移动至右子节点</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">preL</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">preR</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//超了，说明没有右节点</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">TreeNode</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">postL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">postR</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">postR</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">post</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">post</span><span class="p">[</span><span class="n">postR</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pre</span><span class="p">[</span><span class="n">preL</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">postR</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">buildTree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">pre</span><span class="p">,</span><span class="w"> </span><span class="n">preL</span><span class="p">,</span><span class="w"> </span><span class="n">preR</span><span class="p">,</span><span class="w"> </span><span class="n">post</span><span class="p">,</span><span class="w"> </span><span class="n">postL</span><span class="p">,</span><span class="w"> </span><span class="n">postL</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<h4 id="_27">字典树<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h4>
<h5 id="lc440-k"><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">LC440 字典序的第K小数字</a><a class="headerlink" href="#lc440-k" title="Permanent link">&para;</a></h5>
<p>算法思路</p>
<ul>
<li>画出字典树</li>
<li><span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 表示要找到后面的第 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 个元素，起始下标是 0</li>
<li>获取以prefix开头的数字个数，包括他本身
  。 如果数字个数大于 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> ，下移，在prefix <span class="arithmatex"><span class="MathJax_Preview">* 10</span><script type="math/tex">* 10</script></span> 下的子树进行查找 。 如果数字个数小于等于 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> ，右移，在prefix+1下的子树进行查找
  问题的关键是求解 以prefix开头的数字个数，包括他本身</li>
<li>根节点 [prefix, prefix+1 )</li>
<li>第一层 <span class="arithmatex"><span class="MathJax_Preview">[\operatorname{prefix} * 10,(\operatorname{prefix+1)*10)}</span><script type="math/tex">[\operatorname{prefix} * 10,(\operatorname{prefix+1)*10)}</script></span></li>
<li>第二层 [prefix*100, <span class="arithmatex"><span class="MathJax_Preview">\min (\mathrm{n}+1, \quad(\mathrm{prefix}+1) * 100 ）)</span><script type="math/tex">\min (\mathrm{n}+1, \quad(\mathrm{prefix}+1) * 100 ）)</script></span></li>
<li>...</li>
</ul>
<p>```c++
class Solution {
public:
typedef long long LL;
    int findKthNumber(int n, int k) {
        int prefix = 1;
        k--; // k记录要找的数字在prefix后的第几个
        while (k&gt;0){
            int cnt = getCnt(n, prefix); // 当前prefix 下有多少个元素;包含prefix
            if (cnt &lt;= k) { // 向右
                k -= cnt;
                prefix++;
            } else { // 向下
                k--;
                prefix*=10;
            }
        }
        return prefix;
    }
    int getCnt(LL n, LL prefix){
        LL cnt = 0;
        for (LL first = prefix, second = prefix+1; first&lt;=n; first*=10, second*=10){
            cnt+= min(n + 1, second) - first;
        }
        return cnt;
    }
};</p>
<p>作者：muyids
链接：<a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/solution/dfsmo-ni-jian-zhi-guo-cheng-by-muyids/">https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/solution/dfsmo-ni-jian-zhi-guo-cheng-by-muyids/</a>
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
 ```</p>
<h4 id="_28">图<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h4>
<h5 id="_29">出度、入度<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h5>
<h6 id="lc997"><a href="https://leetcode-cn.com/problems/find-the-town-judge/">LC997 找到小镇的法官</a><a class="headerlink" href="#lc997" title="Permanent link">&para;</a></h6>
<blockquote>
<p>本题需要用到有向图中节点的==入度和出度==的概念。在有向图中，一个节点的入度是指向该节点的边的数 量；而一个节点的出度是从该节点出发的边的数量。
思胳及解法
题干描述了一个有向图。每个人是图的节点， trust 的元素 trust[i] 是图的有向边，从 trust [i][0] 指向 trust[i][1]。我们可以遍历 trust，统计每个节点的入度和出度，存储在 inDegrees 和 outDegrees 中。
根据题意，在法官存在的情况下，法官不相信任何人，每个人（除了法官外）都信任法官，且只有一名 法官。因此法官这个节点的入度是 <span class="arithmatex"><span class="MathJax_Preview">n-1</span><script type="math/tex">n-1</script></span>, 出度是 0 。
我们可以遍历每个节点的入度和出度，如果找到一个符合条件的节点，由于题目保证只有一个法官，我 们可以直接返回结果；如果不存在符合条件的点，则返回 <span class="arithmatex"><span class="MathJax_Preview">-1</span><script type="math/tex">-1</script></span> 。</p>
</blockquote>
<h5 id="bfs_1">BFS<a class="headerlink" href="#bfs_1" title="Permanent link">&para;</a></h5>
<h6 id="lc417"><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">LC417 太平洋大西洋水流问题</a><a class="headerlink" href="#lc417" title="Permanent link">&para;</a></h6>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">pacificAtlantic</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="c1">//左右两边加上下两边出发深搜</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w">             </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">visited</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">){</span><span class="w">        </span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">});</span><span class="w"> </span>

<span class="w">        </span><span class="c1">//上下左右深搜</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">visited</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">visited</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"> </span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="mi">-1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">visited</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="mi">-1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">visited</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<h6 id="lc934"><a href="https://leetcode-cn.com/problems/shortest-bridge/">LC934 最短的桥</a><a class="headerlink" href="#lc934" title="Permanent link">&para;</a></h6>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">points</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">direction</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">direction</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="c1">// 收集这个岛屿附近的0</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">points</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">});</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">shortestBridge</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">grid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 找到第一个岛屿</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">isFind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isFind</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="c1">// 调用dfs把这个岛屿都标志为2</span>
<span class="w">                    </span><span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="n">isFind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 找另一个岛屿 BFS</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">points</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">res</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">points</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="n">points</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="c1">// 把这一层的0全部填为2，再把外层的0再加入队列，逐层填陆地，直到碰到第二片岛屿</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">direction</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w"></span>
<span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">direction</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">q</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">q</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="n">points</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">});</span><span class="w"></span>
<span class="w">                        </span><span class="n">grid</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">q</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// 作者：carpe-diem-ew</span>
<span class="c1">// 链接：https://leetcode-cn.com/problems/shortest-bridge/solution/bfs-tian-hai-zao-lu-ti-jie-si-lu-by-carp-6w8j/</span>
<span class="c1">// 来源：力扣（LeetCode）</span>
<span class="c1">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span>
</code></pre></div>
<h5 id="dijkstra-single-source-shortest-pathsssp-algorithm">Dijkstra- Single Source Shortest Path(SSSP) algorithm<a class="headerlink" href="#dijkstra-single-source-shortest-pathsssp-algorithm" title="Permanent link">&para;</a></h5>
<h6 id="lc743"><a href="https://leetcode-cn.com/problems/network-delay-time/">LC743 网络延迟时间</a><a class="headerlink" href="#lc743" title="Permanent link">&para;</a></h6>
<p>第一次实现dijskstra。总之只要记得USA就行：）</p>
<div class="highlight"><pre><span></span><code><span class="cp">#define INF 10000000</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">vis</span><span class="p">[</span><span class="mi">101</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nb">false</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dis</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fa</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">grid</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span><span class="c1">//the path len from i to j</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">[</span><span class="mi">101</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">networkDelayTime</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">times</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="c1">//caculate all minimum path form k to else, and return the biggest</span>
<span class="w">        </span><span class="c1">//ini</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INF</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">fa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">k</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">fa</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">dis</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">vis</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">times</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]};</span><span class="w"></span>
<span class="w">            </span><span class="n">grid</span><span class="p">[</span><span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="mi">-1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">size</span><span class="p">[</span><span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="mi">-1</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="c1">//the number of the point now</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">m</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">[</span><span class="n">cur</span><span class="p">];</span><span class="w"> </span><span class="n">t</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">t</span><span class="p">].</span><span class="n">first</span><span class="p">])</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">t</span><span class="p">].</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dis</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">t</span><span class="p">].</span><span class="n">first</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">dis</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">t</span><span class="p">].</span><span class="n">first</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dis</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">t</span><span class="p">].</span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="n">fa</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">t</span><span class="p">].</span><span class="n">first</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="c1">//update</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INF</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">minV</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">                    </span><span class="n">minV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="c1">//scan for the min unsettled v</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">INF</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">vis</span><span class="p">[</span><span class="n">minV</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">minV</span><span class="p">;</span><span class="c1">//update</span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<h4 id="_30">哈希表<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h4>
<h5 id="lc599"><a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/">LC599 两个列表的最小索引总和</a><a class="headerlink" href="#lc599" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">findRestaurant</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">list1</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">list2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">hashMap</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">list1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">hashMap</span><span class="p">[</span><span class="n">list1</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">minIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100000</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">list2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">hashMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">list2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">hashMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">hashMap</span><span class="p">[</span><span class="n">list2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">minIndex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">ret</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>
<span class="w">                    </span><span class="n">string</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">                    </span><span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="n">minIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">hashMap</span><span class="p">[</span><span class="n">list2</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">hashMap</span><span class="p">[</span><span class="n">list2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">==</span><span class="w">  </span><span class="n">minIndex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">string</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">                    </span><span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<h4 id="dp_1">dp<a class="headerlink" href="#dp_1" title="Permanent link">&para;</a></h4>
<h5 id="lc1575"><a href="https://leetcode-cn.com/problems/count-all-possible-routes/">LC1575 统计所有可行路径</a><a class="headerlink" href="#lc1575" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>解析： <a href="https://leetcode-cn.com/leetbook/read/path-problems-in-dynamic-programming/r8m6e7/">DP - 路径问题 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p>
</li>
<li>
<p>做题反思：</p>
</li>
<li>花了很多时间思考：什么是状态？什么是子问题？怎么写状态转移方程？</li>
<li>思考的方式就是试探，有一些想法，带进去看能不能套用动态规划</li>
<li>有一个想法：所有的点实际上分为两类，记为强点和弱点。由于距离是一维的哈密顿距离，因此将所有的点在数轴上表示，会发现<span class="arithmatex"><span class="MathJax_Preview">例如[1,2,3],1\rightarrow3 和 1\rightarrow2\rightarrow3</span><script type="math/tex">例如[1,2,3],1\rightarrow3 和 1\rightarrow2\rightarrow3</script></span>花费的是同样的油量。也就是说两点内部插入点，是不改边方法数的，只有新加入的点在之前点的两端才会增加油耗。然而这样想的问题在于每一次新加入的点是强点还是弱点是只取决于上一段路径的，因此需要保存上一次的路径，这样就反而变得复杂了。</li>
<li>我的状态转移的想法是：一开始只有起点和终点，然后不断加入新的点，进行状态转移。然而没有想清楚。</li>
</ul>
<h4 id="_31">凸包算法<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h4>
<p>[<a href="https://www.bilibili.com/video/BV1v741197YM?spm_id_from=333.337.search-card.all.click">计算几何]Graham算法构造凸包（重制）_哔哩哔哩_bilibili</a></p>
<h3 id="_32">技巧<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h3>
<h4 id="_33">读题与分析<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h4>
<ul>
<li>看完题意后，看题目的数据量级</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
1)&amp;\ n\leq10^4 \Rightarrow O(N^2)\\
2)&amp;\ 10^5\leq n\leq 10^6(10^7) \Rightarrow O(NlogN)\\
3)&amp; n \geq 10^8 \Rightarrow O(N)
</div>
<script type="math/tex; mode=display">
1)&\ n\leq10^4 \Rightarrow O(N^2)\\
2)&\ 10^5\leq n\leq 10^6(10^7) \Rightarrow O(NlogN)\\
3)& n \geq 10^8 \Rightarrow O(N)
</script>
</div>
<ul>
<li>
<p>出现<span class="arithmatex"><span class="MathJax_Preview">O(logN)</span><script type="math/tex">O(logN)</script></span> 的情形：</p>
</li>
<li>
<p>数据结构（树、堆）</p>
</li>
<li>算法（Kruskal Dijkstra 线段树）其实还是化归到数据结构，或者说利用数据结构进行优化</li>
<li><mark>二分</mark></li>
<li><mark>数位运算</mark></li>
</ul>
<h4 id="_34">打表<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h4>
<h4 id="two-pointers">two pointers<a class="headerlink" href="#two-pointers" title="Permanent link">&para;</a></h4>
<h4 id="_35">滑动窗口（双指针）<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h4>
<p>设置头尾指针，维护两指针（当然，不需要用指针这么可怕的数据类型）间满足条件的序列。
可以很容易发现，当头指针在位置x时，如果获得的最远尾指针在位置y，那么当头指针后移到x+1位置时，尾指针只会停留在原地或是继续后移。
也就是说，这是一个单向移动的过程，时间复杂度就可以简化为O(N)啦！</p>
<h5 id="lc-3">LC 3 无重复字符的最长字串<a class="headerlink" href="#lc-3" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 对于字符串长为0时特殊处理（这里需要这么做，是因为最后答案输出时是ans + 1</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">//头尾下标指针初始化</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">en</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">ch</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ch数组按照ASCII码的值记录每个字符是否已被使用</span>
<span class="w">        </span><span class="n">memset</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ch</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 记录第一位的字符</span>
<span class="w">        </span><span class="n">ch</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 注意，因为String存储范围的下标其实是 0..(len-1)，因此全部处理成en + 1 &lt; len</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">en</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// 利用贪心，如果下一位超出String范围，或是已被使用过，则退出循环</span>
<span class="w">            </span><span class="k">while</span><span class="p">(</span><span class="n">en</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">ch</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">en</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]])</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">en</span><span class="w"> </span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">ch</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">en</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="c1">// 由于ans存储的是尾指针-头指针的数值，因此比实际长度小1</span>
<span class="w">            </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span><span class="w"> </span><span class="n">en</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="c1">// 头指针后移一位</span>
<span class="w">            </span><span class="n">ch</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">st</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="w"> </span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 这里使用ans + 1输出是为了将len = 1的情况一起包括进来，感兴趣的码友可以尝试一下此类数据</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<h4 id="_36">前缀和&amp;差分<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h4>
<h4 id="gridtrick">二维grid上下左右移动的小trick<a class="headerlink" href="#gridtrick" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">};</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">nextR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">direction</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">nextC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">direction</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="_37">浮点数出现精度丢失的问题<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h4>
<p>如果浮点数的精度有限的话，可以将浮点数<span class="arithmatex"><span class="MathJax_Preview">\times 10 ^ n</span><script type="math/tex">\times 10 ^ n</script></span>使得浮点数化成整型，如果需要输出时，只需做一次转换即可。</p>
<div class="highlight"><pre><span></span><code><span class="c1">//浮点数的比较</span>
<span class="k">if</span><span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1e-6</span><span class="p">)</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a = b&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<h1 id="_38">数学基础<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h1>
<h2 id="_39">生成函数<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h2>
<p><a href="https://www.bilibili.com/video/BV16X4y1N74M?spm_id_from=333.337.search-card.all.click">生成函数：函数与数列之间的桥梁 (蒋炎岩)_bilibili</a></p>
<h3 id="_40">引子<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h3>
<ul>
<li>多项式</li>
<li>递推公式：斐波那契数列</li>
<li>
<p>无穷小数：0.9999...</p>
</li>
<li>
<p>结论：一个生成函数里包含了一个无穷数列的每一项。</p>
</li>
</ul>
<h3 id="fibonacci">求Fibonacci 数列<a class="headerlink" href="#fibonacci" title="Permanent link">&para;</a></h3>
<div class="arithmatex">
<div class="MathJax_Preview">
Recursive Define\\
fib(0) = 0, \\
fib(1) = 1,\\
fib(n) = fib(n-1) + fib(n-2);\\
using 生成函数\\
1) F(x) = 0x^0 + 1x^1 + 1x^2 + 2x^3 + 3x^4 + \cdots\\
2)xF(x) = 1x^2 + 1x^3+2x^4 + 3x^5 +\cdots \\
3)x^2F(x) = 1x^3 + 1x^4+2x^5 + 3x^6 +\cdots \\
let (1) - (2) - (3), then \\
(1-x-x^2)F(x) = x\\ \Rightarrow
F(x) = {x\over{1-x-x^2}}\\
部分因式分解，\\
{x\over{1-x-x^2}} \\= \frac{-1-\sqrt{5}}{\sqrt{5}(2 x+\sqrt{5}+1)}+\frac{\sqrt{5}-1}{\sqrt{5}(-2 x+\sqrt{5}-1)}\\=some\ thing\ else +\frac{1}{\sqrt{5}} \frac{1}{1-\left(\frac{1+\sqrt{5}}{2}\right) x}
\\再次利用生成函数的意义，\\
fib(n) = {1\over{\sqrt{5}}}\cdot{\left(\frac{1+\sqrt{5}}{2}\right)}^n x + similar\ one.
</div>
<script type="math/tex; mode=display">
Recursive Define\\
fib(0) = 0, \\
fib(1) = 1,\\
fib(n) = fib(n-1) + fib(n-2);\\
using 生成函数\\
1) F(x) = 0x^0 + 1x^1 + 1x^2 + 2x^3 + 3x^4 + \cdots\\
2)xF(x) = 1x^2 + 1x^3+2x^4 + 3x^5 +\cdots \\
3)x^2F(x) = 1x^3 + 1x^4+2x^5 + 3x^6 +\cdots \\
let (1) - (2) - (3), then \\
(1-x-x^2)F(x) = x\\ \Rightarrow
F(x) = {x\over{1-x-x^2}}\\
部分因式分解，\\
{x\over{1-x-x^2}} \\= \frac{-1-\sqrt{5}}{\sqrt{5}(2 x+\sqrt{5}+1)}+\frac{\sqrt{5}-1}{\sqrt{5}(-2 x+\sqrt{5}-1)}\\=some\ thing\ else +\frac{1}{\sqrt{5}} \frac{1}{1-\left(\frac{1+\sqrt{5}}{2}\right) x}
\\再次利用生成函数的意义，\\
fib(n) = {1\over{\sqrt{5}}}\cdot{\left(\frac{1+\sqrt{5}}{2}\right)}^n x + similar\ one.
</script>
</div>
<h3 id="_41">用函数 (多项式代数) 表示各种数列<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h3>
<blockquote>
<blockquote>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">c \cdot F(x) \rightarrow</span><script type="math/tex">c \cdot F(x) \rightarrow</script></span> 数列倍增</li>
<li><span class="arithmatex"><span class="MathJax_Preview">x \cdot F(x) \rightarrow</span><script type="math/tex">x \cdot F(x) \rightarrow</script></span> 数列右移 (补 0 )</li>
<li><span class="arithmatex"><span class="MathJax_Preview">[F(x)-f(0)] / x \rightarrow</span><script type="math/tex">[F(x)-f(0)] / x \rightarrow</script></span> 数列左移</li>
<li><span class="arithmatex"><span class="MathJax_Preview">F_{1}(x) \pm F_{2}(x) \rightarrow</span><script type="math/tex">F_{1}(x) \pm F_{2}(x) \rightarrow</script></span> 数列求和/差</li>
<li><span class="arithmatex"><span class="MathJax_Preview">F^{\prime}(x) \rightarrow</span><script type="math/tex">F^{\prime}(x) \rightarrow</script></span> 数列乘幂次 <span class="arithmatex"><span class="MathJax_Preview">+</span><script type="math/tex">+</script></span> 左移</li>
<li>导数:<span class="arithmatex"><span class="MathJax_Preview">(c)^{\prime}=0,\\ \left(x^{n}\right)^{\prime}=n x^{n-1}</span><script type="math/tex">(c)^{\prime}=0,\\ \left(x^{n}\right)^{\prime}=n x^{n-1}</script></span></li>
<li><span class="arithmatex"><span class="MathJax_Preview">F_{1}(x) \cdot F_{2}(x) \rightarrow</span><script type="math/tex">F_{1}(x) \cdot F_{2}(x) \rightarrow</script></span> 数列卷积</li>
<li><span class="arithmatex"><span class="MathJax_Preview">F(x)\cdot {1\over{1-x}}</span><script type="math/tex">F(x)\cdot {1\over{1-x}}</script></span>为<span class="arithmatex"><span class="MathJax_Preview">F(x)</span><script type="math/tex">F(x)</script></span>代表的数列的前n项和的生成函数</li>
</ul>
</blockquote>
</blockquote>
<h2 id="_42">乘法逆元<a class="headerlink" href="#_42" title="Permanent link">&para;</a></h2>
<h3 id="c_nk-mod-pc_nk-mod-p">从组合数<span class="arithmatex"><span class="MathJax_Preview">C_n^k \mod p</span><script type="math/tex">C_n^k \mod p</script></span>的快速求法说起<a class="headerlink" href="#c_nk-mod-pc_nk-mod-p" title="Permanent link">&para;</a></h3>

  <hr>
<div class="md-source-file">
  <small>
    
      最后更新:
      <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">March 17, 2023</span>
      
    
  </small>
</div>




              
            </article>
            
          </div>
        </div>
        
          <a href="#" class="md-top md-icon" data-md-component="top" hidden>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            回到页面顶部
          </a>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="页脚" >
      
        
        <a href="../../Math/LinearAlgebra/Linear-algebra-notes/" class="md-footer__link md-footer__link--prev" aria-label="上一页: 线性代数" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                上一页
              </span>
              线性代数
            </div>
          </div>
        </a>
      
      
        
        <a href="../%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="md-footer__link md-footer__link--next" aria-label="下一页: 高级程序设计" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                下一页
              </span>
              高级程序设计
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2022 by yunzinan
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "search.suggest", "search.share", "navigation.top"], "search": "../../assets/javascripts/workers/search.ecf98df9.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.9c69f0bc.min.js"></script>
      
        <script src="../../js/extra.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>